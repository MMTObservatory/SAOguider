#!/bin/sh
# The backslash makes the next line a comment in Tcl \
exec tclsh "$0" ${1+"$@"}

set catget_loaded 1
# ####
#
# starbase.tcl -- Tcl interface to starbase
#
# ####

# Starbase Tables Interface
#

set starbasedebug 0

proc Starbase {} {
	global  Starbase
	return $Starbase(version)
}

set Starbase(version) "Starbase Tcl Driver 1.0"

proc starbase_nrows   { D } 	        { upvar $D T; return $T(Nrows) 	}
proc starbase_ncols   { D } 	        { upvar $D T; return $T(Ncols) 	}
proc starbase_get     { D row col }     { upvar $D T; return $T($row,$col) }
proc starbase_set     { D row col val } { upvar $D T; set T($row,$col) $val; 	}
proc starbase_colname { D col  }        { upvar $D T; set row 0; 
						return $T($row,$col)}
proc starbase_columns { D      }        { upvar $D T; return $T(Header) }
proc starbase_colnum  { D name }        { upvar $D T; if { [catch { set num $T($name) }] } {
            set num 0 }; return $num
}

proc starbase_init { t } {
	upvar t T

	set T(Nrows) 0
	set T(Ncols) 0
	set T(Header) ""
}

# Set up a starbase data array for use with ted
#
proc starbase_driver { Dr } {
	upvar $Dr driver

	set driver(nrows)	starbase_nrows
	set driver(ncols)	starbase_ncols
	set driver(get)		starbase_get
	set driver(set)		starbase_set
	set driver(colname)	starbase_colname
	set driver(colnum)	starbase_colnum
	set driver(columns)	starbase_columns
	set driver(colins)	starbase_colins
	set driver(coldel)	starbase_coldel
	set driver(colapp)	starbase_colapp
	set driver(rowins)	starbase_rowins
	set driver(rowdel)	starbase_rowdel
	set driver(rowapp)	starbase_rowapp
}
starbase_driver Starbase

proc starbase_new { t cols } {
	upvar $t T

    set T(Header) $cols
    set T(Ndshs)  [llength $T(Header)]
    set T(HLines) 2
    starbase_colmap T

    set T(Nrows) 0
}

proc starbase_hdrcpy { t c } {
    	upvar $t T
	upvar $c C

    array set C [array get T H_*]
    array set C [array get T N_*]
    set C(HLines) T(HLines)
}

proc starbase_colmap { t } {
	upvar $t T

    set r 0
    set c 0	
    foreach column $T(Header) {
	incr c
	set column [string trim $column]
	set T($column) $c
	set T($r,$c) $column
    }
    set T(Ncols) $c
}

proc starbase_coldel { t here } {
	upvar $t T

    set Ncols $T(Ncols)

    set T(Header) [lreplace $T(Header) [expr $here - 1] [expr $here - 1]]
    set T(Dashes) [lreplace $T(Dashes) [expr $here - 1] [expr $here - 1]]
    starbase_colmap T

    for { set row 1 } { $row <= $T(Nrows) } { incr row } {
        for { set col $here } { $col < $Ncols } { incr col } {
	    if { [catch { set val $T($row,[expr $col + 1]) }] } {
		set T($row,$col) ""
	    } else {
	        set T($row,$col) $val
	    }
	}
    }
}

proc starbase_colapp { t name { here -1 } } {
	upvar $t T

	if { $here == -1 } {
		set here $T(Ncols)
	}
	starbase_colins T $name [expr $here + 1]
}

proc starbase_colins { t name here } {
	upvar $t T

    if { [info exists T(Header)] == 0 } {
	set T(Header) $name
    } else {
        set T(Header) [linsert $T(Header) [expr $here - 1] $name]
    }
    starbase_colmap T

    set Nrows $T(Nrows)
    for { set row 1 } { $row <= $Nrows } { incr row } {
        for { set col $T(Ncols) } { $col > $here } { incr col -1 } {
	    if { [catch { set val $T($row,[expr $col - 1]) }] } {
		set T($row,$col) ""
	    } else {
	        set T($row,$col) $val
	    }
	}
    }

    for { set row 1 } { $row <= $Nrows } { incr row } {
	set T($row,$here) ""
    }

    return $here
}

proc starbase_header { t fp } {
	upvar $t T
	global starbase_line
	set N 1

    if { [info exists starbase_line] } {
	set line $starbase_line
	set n 1

	set T(H_$n) $line
	if { [regexp -- {^ *(-)+ *(\t *(-)+ *)*} $line] } break
	if { $n >= 2 } {
	    set ind [string first "\t" $T(H_[expr $n-1])]
	    if { $ind >= 0 } {
		set name [string trim [string range  $T(H_[expr $n-1]) 0 [expr $ind - 1]]]
		incr ind
		set T(H_$name) [string range $T(H_[expr $n-1]) $ind end]
		set T(N_$name) [expr $n-1]
	    }
	}

	unset starbase_line
	set N 2
    }
    for { set n $N } { [set eof [gets $fp line]] != -1 } { incr n } {
	set T(H_$n) $line
	if { [regexp -- {^ *(-)+ *(\t *(-)+ *)*} $line] } break

	if { $n >= 2 } {
	    set ind [string first "\t" $T(H_[expr $n-1])]
	    if { $ind >= 0 } {
		set name [string trim [string range  $T(H_[expr $n-1]) 0 [expr $ind - 1]]]
		incr ind
		set T(H_$name) [string range $T(H_[expr $n-1]) $ind end]
		set T(N_$name) [expr $n-1]
	    }
	}
    }

    if { $eof == -1 } {
	error "ERROR: in starbase_header: unexpected eof"
    }

    set T(H_$n) $line
    set T(HLines) $n

    set T(Header) [split $T(H_[expr $n-1])  "\t"]
    set T(Dashes) [split $T(H_$n)	    "\t"]
    set T(Ndshs)  [llength $T(Dashes)]

    starbase_colmap T

    return $T(Header)
}

proc starbase_hdrget { t name } {
    upvar $t T

    return $T(H_$name)
}

proc starbase_hdrset { t name value } {
    upvar  $t T 

    if { ![info exists T(H_$name)] } {
	set n [incr T(HLines)]

	set T(H_[expr $n-0]) $T(H_[expr $n-1])
	set T(H_[expr $n-1]) $T(H_[expr $n-2])
	set T(N_$name) [expr $n-2]
    }
    set T(H_$name) 	  $value
    set T(H_$T(N_$name)) "$name	$value"
}

proc starbase_hdrput { t fp } {
	upvar $t T

    if { [info exists T(HLines)] && ($T(HLines) != 0)  } {
	    set nl [expr $T(HLines) - 2]
	    for { set l 1 } { $l <= $nl } {  incr l } {
		puts $fp $T(H_$l)
	    }
    }

    if { ![info exists T(Ncols)] || ($T(Ncols) == 0)  } {
	return
    }

    set r 0
    set Ncols $T(Ncols)
    for { set c 1 } { $c <= $Ncols } {  incr c } {
	puts -nonewline $fp "$T($r,$c)"
	if { $c != $Ncols } {
	    puts -nonewline $fp "\t"
	} else {
	    puts -nonewline $fp "\n"
	}
    }

    for { set c 1 } { $c <= $Ncols } {  incr c } {
	set len [string length $T($r,$c)]
	for { set d 1 } { $d <= $len } { incr d } {
	    puts -nonewline $fp "-"
	}
	if { $c != $Ncols } {
	    puts -nonewline $fp "\t"
	} else {
	    puts -nonewline $fp "\n"
	}
    }
}

proc starbase_readfp { t fp } {
	upvar $t T

    starbase_header T $fp

    set NCols [starbase_ncols T]

    for { set r 1 } { [gets $fp line] != -1 } { incr r } {
	if { [string index $line 0] == "\f" } {
	    global starbase_line
	    set starbase_line [string range $line 1 end]
	    break
	}
	set c 1
	foreach val [split $line "\t"] {
	    set T($r,$c) [string trim $val]
	    incr c
	}
	for { } { $c <= $NCols } { incr c } {
	    set T($r,$c) {}
	}
    }
    set T(Nrows) [expr $r-1]
}

proc starbase_read { t file } {
	upvar $t T

    set fp [open $file]
    starbase_readfp T $fp
    close $fp

    set T(filename) $file
}

proc starbase_writefp { t fp } {
	upvar $t T

    starbase_hdrput T $fp

    if { ![info exists T(Nrows)] || ($T(Nrows) == 0)  } {
	return
    }

    set Nrows $T(Nrows)
    set Ncols $T(Ncols)
    for { set r 1 } { $r <= $Nrows } {  incr r } {
	for { set c 1 } { $c < $Ncols } {  incr c } {
	    if { [catch { set val $T($r,$c) }] } {
		    set val ""
	    }

	    if { [regexp {[\n\t]} $val] } {
		error "Table cell $r,$c contains a newline or tab: $val"
	    }

	    puts -nonewline $fp "$val	"
	}
	if { [catch { set val $T($r,$c) }] } {
		set val ""
	}

	if { [regexp {[\n\t]} $val] } {
	    error "Table cell $r,$c contains a newline or tab: $val"
	}

	puts $fp $val
    }
}

proc starbase_write { t file } {
	upvar $t T

    set fp [open $file w]
    fconfigure $fp -translation { auto lf }
    starbase_writefp T $fp
    close $fp
}

proc starbase_rowapp { t { row -1 } { rowval {} } } {
		upvar $t T

	if { $row == -1 || $row == "" } {
		set row $T(Nrows)
	}
	starbase_rowins T [expr $row + 1] $rowval
}

proc starbase_rowins { t row { rowval {} } } {
		upvar $t T

	if { $row == "" } {
	    set row 1
	}

	incr T(Nrows)

	set Nrows $T(Nrows)
	set Ncols $T(Ncols)
	for { set r $Nrows } { $r > $row } { set r [expr $r-1] } {
	    for { set c 1 } { $c <= $Ncols } { incr c } {
		if { [catch { set val $T([expr $r-1],$c) }] } {
			set val ""
		}
			
	        set T($r,$c) $val
	    }
	}

	starbase_rowset T $r $rowval
}

proc starbase_rowset { t r { rowval {} } } {
    upvar $t T

	set Ncols $T(Ncols)
	for { set c 1 } { $c <= $Ncols } { incr c } {
	    set T($r,$c) [lindex $rowval [expr $c - 1]]
	}
}

proc starbase_rowget { t r } {
    upvar $t T

	set Ncols $T(Ncols)
	for { set c 1 } { $c <= $Ncols } { incr c } {
	    lappend row $T($r,$c)
	}

    return $row
}

proc starbase_rowdel { t { row -1 } } {
	upvar $t T

    if { $row == "" } 	    { set row -1 }
    if { $T(Nrows) <= 0   } { return 	 }
    if { $row > $T(Nrows) } { return 	 }

    incr T(Nrows) -1

    set Nrows $T(Nrows)
    set Ncols $T(Ncols)
    for { set r $row } { $r <= $Nrows } { incr r } {
	for { set c 1 } { $c <= $Ncols } { incr c } {
	    if { [catch { set val $T([expr $r+1],$c) }] } {
		    set val ""
	    }
		    
	    set T($r,$c) $val
	}
    }

    for { set c 1 } { $c <= $Ncols } { incr c } {
	set T($r,$c) ""
    }
}

proc starbase_httpreader { t wait sock http } {
	global $t
        global starbasedebug
	upvar #0 $wait W
	upvar #0 $t T

    set T(http) $http

    if { ![info exists T(state)]  } {
      error "ERROR: starbase_httpreader not properly initialized"
    }

    switch -- $T(state) {
	0 {
	    fconfigure $sock -blocking 1
	    set T(state)	1
	    set T(Nrows)	0
	    set T(HLines)	0
	}

	1 {
	    incr ${t}(HLines)
	    set n $T(HLines)
		
	    if { [gets $sock line] == -1 } {
		set T(state) -1
		set T(HLines) [expr $T(HLines) - 1]
		set T(Nrows) 0
		return
	    }

	    if { $n >= 2 } {
		set ind [string first "\t" $T(H_[expr $n-1])]
		if { $ind >= 0 } {
		    set name [string trim [string range  $T(H_[expr $n-1]) 0 [expr $ind - 1]]]
		    incr ind
		    set T(H_$name) [string range $T(H_[expr $n-1]) $ind end]
		    set T(N_$name) [expr $n-1]
		}
	    }

	    set T(H_$n) $line

	    if { [regexp -- {^ *(-)+ *(\t *(-)+ *)*} $line] } {
		set T(Header) [split $T(H_[expr $n-1])  "\t"]
		set T(Dashes) [split $T(H_$n)		"\t"]
		set T(Ndshs)  [llength $T(Dashes)]
		
		starbase_colmap T
		set T(state) 2
	    }
	}

	2 {
	    if { [gets $sock line] == -1 } {
		set T(state) 0
	    } else {
		if { $starbasedebug } { 
		    puts [format "starbase_httpreader: %s" $line]
		}
		incr ${t}(Nrows)
		set r $T(Nrows)
		
		set NCols [starbase_ncols T]
		set c 1
		foreach val [split $line "\t"] {
		    set T($r,$c) $val
		    incr c
		}
		for { } { $c <= $NCols } { incr c } {
		    set T($r,$c) {}
		}
	    }
	}

	default {
	    error "ERROR: unknown switch in starbase_httpreader"
	}
    }
}

proc starbase_cancel { t wait http } {
	upvar #0 $wait W
	upvar #0 $t T

	set W 1
}

proc starbase_http { t url wait } {
    upvar #0 $t T

    set T(state) 0
    set T(http) [http::geturl $url 				\
		-handler [list starbase_httpreader $t $wait] 	\
		-command [list starbase_cancel $t $wait]]
}

proc starbase_httpkill { t } {
	upvar #0 $t T

    http::reset $T(http)
}

proc starbasetolist { t } {
	upvar $t T

    for { set j 0 } { $j <= $T(Nrows) } { incr j } {
        for { set i 1 } { $i <= $T(Ncols) } { incr i } {
	    lappend Col$j $T($j,$i)
        }
	lappend Cols [set Col$j]
    }

    return $Cols
}

proc listtostarbase { t l } {
	upvar $t T

	set r 0
	foreach row $l {
	    set c 0
	    foreach col $row {
		incr c
		set T($r,$c) $col
	    }
	    incr r
	}

	set T(Nrows) [expr $r -1]
	set T(Ncols) $c

	return $t
}

proc sorttable { t columns { s All } { functions {} } args } {
	upvar $t T

    if { ![string compare $s {}] } { return {} }


    if { ![string compare $s All] } {
	# Make a selection list
	#
	set s {}
	for { set j 1 } { $j <= $T(Nrows) } { incr j } {
	    lappend s $j
	}
    }

    # Make a sort list
    #
    foreach row $s {
	set l {}
	foreach $col $columns \
		$fun $function {
	    lappend l $row
            set c [starbase_colnum T $col]

	    if { ![string compare $fun {}] } {
	        lappend l $T($row,$c)
	    } else {
		lappend l [eval $fun $T($row,$c)]
	    }
	}
	lappend L $l
    }

    set s {}
    set L [eval lsort -index 1 $args \$L]
    foreach row $L {
	lappend s [lindex $row 0]
    }
    return $s
}

# Example
#
# set col [starbase_colnum Exp CatalogRow]
# set colrow guy
# 
# set selectexpr [subst { expr \$T(\$row,$col) == $catrow }]
# set rowlist [selecttable Exp $selectexpr]

proc selecttable { t expr { s All } } {
	upvar $t T

    if { ![string compare $s All] } {
	# Make a selection list
	#
	set s {}
	for { set j 1 } { $j <= $T(Nrows) } { incr j } {
	    lappend s $j
	}
    }

    set L {}
    foreach row $s {
	if { [eval $expr] } { lappend L $row }
    }

    return $L
}

proc starbase_foreachrow { T body } {
    uplevel [subst { 
	for { set row 1 } { \$row <= \${${T}(Nrows)} } { incr row } {
	$body
    } }]
}
proc starbase_foreachcol { T body } {
    uplevel [subst { 
	for { set col 1 } { \$col <= \${${T}(Ncols)} } { incr col } {
	$body
    } }]
}
# ####
#
# w3browse.tcl -- a Tcl Interface to HEASARC BROWSE W3Query Engine
#
# ####

proc sql_header { h fp } {
	upvar $h H

    while { [gets $fp line] != -1 } {
	if { [regexp "^BatchStart$" $line ] } { break }
    }
    set H(HLines) 2

    gets $fp line
    regsub -all {'}  $line ""  line
    regsub -all {\(} $line "_" line
    regsub -all {\)} $line ""  line
    regsub -all {([a-zA-Z0-9])_([ |])} $line {\1\2} line

    regsub      {^\|} $line ""  line
    regsub      {\|$} $line ""  line
    regsub -all {\|}  $line "\t" line
    set H(H_1) $line
    set H(Header) [split $line "\t"]

    gets $fp line
    regsub      {^\+} $line ""  line
    regsub      {\+$} $line ""  line
    regsub -all {\+} $line "\t"	line
    set H(H_2) $line
    set H(Dashes) [split $line "\t"]
    set H(Ndshs)  [llength $H(Dashes)]

    starbase_colmap H

    return H(Header)
}

proc w3browse_readfp { t fp } {
	upvar $t T

    sql_header T $fp
    set NCols [starbase_ncols T]

    for { set r 1 } { [gets $fp line] != -1 } { incr r } {
	set c 1
	if { [regexp "^BatchEnd$" $line] } { break }

	regsub      {^\|} $line ""  line
	regsub      {\|$} $line ""  line
	foreach val [split $line {\|}] {
	    set T($r,$c) $val
	    incr c
	}
	for { } { $c <= $NCols } { incr c } {
	    set T($r,$c) {}
	}
    }

    # Read up the rest of the file
    #
    while { [gets $fp line] != -1 } { }

    set T(Nrows) [expr $r-1]
}

proc w3browse_httpreader { t sock http } {
	upvar #0 $t T

    fconfigure $sock -blocking 1
    w3browse_readfp T $sock
}
proc w3browse_http { t url } {
    global $t
    upvar #0 $t T

    set T(http) [http::geturl $url -handler "w3browse_httpreader $t"]
}
# ####
#
# nameserver.tcl -- NED/SIMBAD namer server interface
#
# ####

#
# call NED or SIMBAD name servers to resolve an object name
# 

proc name_server { t server entry } {
    global $t
    global wait
    upvar $t T
    
    switch $server {
	simbad {
	    set name sim
	}
	ned {
	    set name ned
	}
    }

    set nsURL "http://archive.eso.org/skycat/servers/$name-server?&o=$entry"

    set T(state) 0
    starbase_http T $nsURL wait

    # add history information
    starbase_hdrset T "ORG" $server
    starbase_hdrset T "OBJ" $entry
    starbase_hdrset T "URL" $nsURL

    if { $T(state) == -1 } {
	if { [info exists T(H_***)]  } {
	    starbase_hdrset T "MISSING" $T(H_***)
	} else {
	    starbase_hdrset T "MISSING" $entry
	}
    }
}
# ####
#
# table.tcl -- high level table routines (layered on starbase routines) 
#
# ####

# Table driver wrappers
#
proc tab_nrows  { D }			{ upvar #0 $D data; $data(nrows)   data 		}
proc tab_ncols  { D }			{ upvar #0 $D data; $data(ncols)   data 		}
proc tab_set    { D row col value }	{ upvar #0 $D data; $data(set)     data $row $col $value}
proc tab_get    { D row col } 		{ upvar #0 $D data; $data(get)     data $row $col 	}
proc tab_colname { D col }		{ upvar #0 $D data; $data(colname) data $col 		}
proc tab_columns { D     }		{ upvar #0 $D data; $data(columns) data  		}
proc tab_colnum { D name } 		{ upvar #0 $D data; $data(colnum)  data $name 		}
proc tab_coldel { D col }		{ upvar #0 $D data; $data(coldel)  data $col		}
proc tab_colins { D name here }		{ upvar #0 $D data; $data(colins)  data $name $here	}
proc tab_colapp { D name }		{ upvar #0 $D data; $data(colapp)  data $name		}
proc tab_rowdel { D row }		{ upvar #0 $D data; $data(rowdel)  data $row		}
proc tab_rowins { D here }		{ upvar #0 $D data; $data(rowins)  data $here		}
proc tab_rowapp { D row }		{ upvar #0 $D data; $data(rowapp)  data $row		}

proc tab_driver { D Dr } {
	upvar $D  data
	upvar $Dr driver

	set data(nrows)		$driver(nrows)
	set data(ncols)		$driver(ncols)
	set data(get)		$driver(get)
	set data(set)		$driver(set)
	set data(colname)	$driver(colname)
	set data(colnum)	$driver(colnum)
	set data(columns)	$driver(columns)
	set data(colins)	$driver(colins)
	set data(coldel)	$driver(coldel)
	set data(colapp)	$driver(colapp)
	set data(rowins)	$driver(rowins)
	set data(rowdel)	$driver(rowdel)
	set data(rowapp)	$driver(rowapp)
}

# ####
#
# options.tcl -- option list parser for starcat
#
# ####

# catOptions --
#
#	Parses a list of "-option value" pairs. If all options and
#	values are legal, the values are stored in a string of the
#	form:
#		key1=value1&key2=value2 ...
#
#	Otherwise an error message is returned.
#
# Arguments:
#
#
# specs = {
#    {-commandlineswitch keyname mode(r or o) [defaultValue]}
#    {....}
# }
#
# NB: they keyname should contain the "=" character if that is what
# if wanted.
#
# argList = The list of  "-option value" pairs.
#
# code modelled after Tk/library/comdlg.tcl
#
set optionsURL  http://cfa-www.harvard.edu/catalog/options

proc catOptions {url org argList} {
    global optionsURL
    global I
    global wait
    global env

    #
    # 0: get options list
    if { [info exists env(CAT_OPTIONS_URL)] } {
	starbase_read I $env(CAT_OPTIONS_URL)
    } else {
	starbase_http I $optionsURL wait
    }
    set org_col     [starbase_colnum I org]
    set switch_col  [starbase_colnum I switch]
    set keyword_col [starbase_colnum I keyword]
    set mode_col    [starbase_colnum I mode]
    set desc_col    [starbase_colnum I description]
    set default_col [starbase_colnum I default]

    # 1: Put the specs in associative arrays for faster access
    #
    for { set row 1 } { $row <= $I(Nrows) } { incr row } {
	if { $org != $I($row,$org_col) } {
	    continue
	}
	set cmdsw $I($row,$switch_col)
	set cmd($cmdsw) ""
	set key($cmdsw)    $I($row,$keyword_col)
	set mode($cmdsw)   $I($row,$mode_col)
	if { $I($row,$default_col) != "N/A" } {
	    if {$mode($cmdsw) == "r"} {
	        error "ERROR: required option '$cmdsw' cannot have a default value"
	    }
	    set def($cmdsw) $I($row,$default_col)
	}
    }

    if {[llength $argList] & 1} {
	set cmdsw [lindex $argList end]
	if {![info exists cmd($cmdsw)]} {
	    error "ERROR: bad option '$cmdsw': must be [catListValidFlags cmd]"
	} else {
	    error "ERROR: value for '$cmdsw' missing"
	}
    }

    # 2: init the default values where possible
    #
    foreach cmdsw [array names cmd] {
	if {[info exists def($cmdsw)]} {
	  set val($cmdsw) $def($cmdsw)
        }
    }

    # 3: parse the argument list
    #
    foreach {cmdsw value} $argList {
	if {![info exists cmd($cmdsw)]} {
	    error "ERROR: bad option '$cmdsw': must be [catListValidFlags cmd]"
	}
	set val($cmdsw) $value
    }

    # 4: make sure all required args are specified
    #
    foreach cmdsw [array names cmd] {
	if { [string first r $mode($cmdsw)] >= 0 } {
	    if {![info exists val($cmdsw)]} {
	        error "ERROR: missing required option '$cmdsw'"
            }
        }
    }

    # 5: generate string
    #
    set len [llength [array names val]]
    foreach cmdsw [array names val] {
        # expand macro
	if { [string first e $mode($cmdsw)] >= 0 } {
	    regsub -all -- %$key($cmdsw)% $url $val($cmdsw) url
        # add argument (and & if needed)
        } elseif { [string first a $mode($cmdsw)] >= 0 } {
	    set n [string last "?" $url]
	    if { ($n >= 0) && ([expr $n + 1] < [string length $url]) } {
	        append url "&"
	    }
	    append url [format "%s=%s" $key($cmdsw) $val($cmdsw)]
	} else {
	    error "ERROR: invalid mode ($mode($cmdsw)) for '$cmdsw'"
	}
    }

    # make sure all spaces are replaced with +
    regsub -all -- "\\+-" $url  "-" url
    regsub -all -- " "  $url  "+" url

    # Done!
    return $url
}

proc catListValidFlags {v} {
    upvar $v cmd

    set len [llength [array names cmd]]
    set i 1
    set separator ""
    set errormsg ""
    foreach cmdsw [lsort [array names cmd]] {
	append errormsg "$separator$cmdsw"
	incr i
	if {$i == $len} {
	    set separator ", or "
	} else {
	    set separator ", "
	}
    }
    return $errormsg
}
# ####
#
# convert.tcl -- unit and format conversion routines
#
# ####

set M_PI 3.14159265358979323846

# hours to degrees
proc h2d { h } {
    return [expr ($h + 0.0) * 15.0]
}

# degrees to hours
proc d2h { d } {
    return [expr ($d + 0.0) / 15.0]
}

# degrees to radians -- returns 0 <= r < PI
proc d2r { d } {
    global M_PI
    while { $d >= 360.0 } {
	set d [expr $d - 360.0]
    }
    return [expr ($d + 0.0) * ($M_PI / 360.0) ]
}

# radians to degrees -- returns 0 <= d < PI
proc r2d { r } {
    global M_PI
    while { $r >= $M_PI } {
	set r [expr $r - $M_PI]
    }
    return [expr ($r + 0.0) * (360.0 / $M_PI) ]
}

#
#    strtod -- convert string to double
#
#    Supports sexagesimal values:
#    12:30:45.6 12h30m45.6s 12d30m45.6s "12 30 45.6"

#    Supports 12.5d (degrees) 12.5r (radians)
#
#    A hidden global _strtod returns the number of arguments in the input.
#    if this value is 3 or 4, then hms or dms was input. This can be used
#    to determine that hms was input for ra so that you can convert hours
#    to degrees.
#    
#
set _strtod 0
proc strtod { d } {
    global _strtod

    set d [string trim $d]
    set d [string trimleft $d 0]
    if { $d == "" } {
	set d 0
    }

    if { [string first - $d] >= 0 } {
      set sign "-"
      regsub -all -- "-" $d  "" d
    } else {
      set sign ""
    }

    regsub -all {[ \t]*[hms][ \t]*} $d   ":" d
    set arglist [split $d ": "]

    set _strtod 0
    foreach arg $arglist {
	set args($_strtod) [string trimleft $arg 0]
	if { $args($_strtod) == "" } {
	    set args($_strtod) 0
	}
	incr _strtod
    }


    switch $_strtod {
	2 {
	    error "ERROR: strtod h:m:s|d:m:s|d"
	}
	3 {
	    foreach i { 0 1 2 } {
		regsub {^\+} $args($i) "" args($i)
		regsub {^0}  $args($i) "" args($i)
		if { $args($i)=="" } { set args($i) 0 }
	    }
	    set d [expr double($args(0)) + 0.0];
	    set m [expr double($args(1)) + 0.0];
	    set s [expr double($args(2)) + 0.0];
	}
	4 {
	    foreach i { 0 1 2 } {
		regsub {^\+} $args($i) "" args($i)
		regsub {^0}  $args($i) "" args($i)
		if { $args($i)=="" } { set args($i) 0 }
	    }
	    set d [expr double($args(0)) + 0.0];
	    set m [expr double($args(1)) + 0.0];
	    set s [expr double($args(2)) + 0.0];
	}
	default {
            set c [string range $d end end]
            if { $c == "r" } {
		set d [string trimright $d r]
		set d [r2d $d]
            } elseif { $c == "d" } {
		set d [string trimright $d d]
	    }
	    set m 0
	    set s 0
	}
    }

    set val [expr  $d + ($m / 60.0) + ($s / 3600.0)]
    set val [format "%s%.16f" $sign $val]
    return $val
}

#
# _uformat -- primative unit format converter to convert a float to a string
# output format can be:
#   # or : (output in sexagesimal) or d (output in decimal)
#
proc _uformat { oformat value { prec 6 } } {

    if { $value < 0.0 } {
	set sign "-"
	set d [expr -$value]
    } else {
	set sign ""
	set d $value
    }
    switch $oformat {
	{#} { 
	    set m [expr ($d - (int($d))) * 60]
	    if { $m < 0 } {
		set m 0.0
	    }
	    set s [expr ($m - (int($m))) * 60]
	    if { $s < 0 } {
		set s 0.0
	    }
	    return [format "%s%d %d %.${prec}f" $sign [expr int($d)] [expr int($m)] $s]
	}
	:   {
	    set m [expr ($d - (int($d))) * 60]
	    if { $m < 0 } {
		set m 0.0
	    }
	    set s [expr ($m - (int($m))) * 60]
	    if { $s < 0 } {
		set s 0.0
	    }
	    return [format "%s%d:%d:%.${prec}f" $sign [expr int($d)] [expr int($m)] $s]
	}
	d  {
	    return [format "%s%.${prec}f" $sign $d]
	}
    }
}

#
# uformat -- unit format converter
#
# uformat input_format output_format value
#
# where input format can be:
#   h (hours) d (degrees) m (minutes) s (seconds)
# and output format can be the same, with a suffix of:
#   # or : (output in sexagesimal) or d (output in decimal)
#
proc uformat { iformat oformat value { prec 6 } } {
    set itype [string index $iformat 0]
    set otype [string index $oformat 0]
    set oform [string index $oformat 1]
    if { $oform == "" } {
	set oform d
    }
    set value [strtod $value]

    switch $itype {
	h {
	    switch $otype {
		h   { return [_uformat $oform $value 			$prec]	}
		d   { return [_uformat $oform       [h2d $value]        $prec]  }
		m   { return [_uformat $oform [expr [h2d $value]*60]    $prec]  }
		s   { return [_uformat $oform [expr [h2d $value]*60*60] $prec]  }
	    }
	}
	d {
	    switch $otype {
		h   { return [_uformat $oform [d2h  $value]       $prec] }
		d   { return [_uformat $oform       $value        $prec] }
		m   { return [_uformat $oform [expr $value*60]    $prec] }
		s   { return [_uformat $oform [expr $value*60*60] $prec] }
	    }
	}
	m {
	    switch $otype {
		h   { return [_uformat $oform [expr [d2h  $value/60.0]] $prec] }
		d   { return [_uformat $oform [expr $value/60.0]]       $prec  }
		m   { return [_uformat $oform       $value]           $prec  }
		s   { return [_uformat $oform [expr $value*60.0]]       $prec  }
	    }
	}
	s {
	    switch $otype {
		h   { return [_uformat $oform [expr [h2d  $value/60.0/60.0]] $prec] }
		d   { return [_uformat $oform [expr $value/60.0/60.0]        $prec] }
		m   { return [_uformat $oform [expr $value/60.0]		 $prec] }
		s   { return [_uformat $oform           $value 		 $prec] }
	    }
	}
    }
}

# ####
#
# catreg.tcl -- convert starbase catalogs to regions (generalized format)
#
# ####

set debug 0

set catreg_version 1.0b1

set catreg_tokens	"BEGIN SYSTEM SHAPE RA DEC SIZE COLOR TEXT TAG END"
set catreg_colors	"green red blue yellow cyan magenta white black"
set catreg_shapes	"circle ellipse box"
set catreg_missing	"**CATREG MISSING**"

array set catreg_def {
    REGION	"%SYSTEM%;%SHAPE%(%RA%,%DEC%,%SIZE%) # color=%COLOR% text=%TEXT% tag=%TAG%"
    BEGIN	{Constant "# Region file format: DS9 version 3.0"}
    SYSTEM	"Header equinox fk5"
    SHAPE	"Constant circle"
    RA 		"Column ra"
    DEC 	"Column dec"
    SIZE	"Constant 5p,5p,0"
    COLOR	"Constant green"
    TEXT	"Constant \"\""
    TAG		"Constant \"\""
}
array set catreg_ds9 [array get catreg_def]

#
# catreg_value -- use a method to return a value
#
proc catreg_value { t row token method_list } {
    global catreg_err catreg_missing
    upvar $t T
    upvar _lookup lookup

    foreach method [split $method_list ";"] {
	set value ""
	set type [lindex  $method 0]
	set arg1 [lindex  $method 1]
	set len  [llength $method]
	switch $type {
	    Constant {
		set value $arg1
	    }
	    Column {
		if { ($len < 2) || ($len > 3) } {
		    error "ERROR: Column requires 1 or 2 args: column defval"
		}
		if { [catch {starbase_colnum T $arg1} col] == 0 } {
		    set value [starbase_get T $row $col]
		} else {
		    if { $len == 3 } {
			set value [lindex $method 2]
		    } else {
			error "ERROR: missing column: $arg1"
		    }
		}
	    }
	    Header {
		if { ($len < 2) || ($len > 3) } {
		    error "ERROR: Header requires 1 or 2 args: header defval"
		}
		if { [catch {starbase_hdrget T $arg1} value] != 0 } {
		    if { $len == 3 } {
			set value [lindex $method 2]
		    } else {
			error "ERROR: missing header value: $arg1"
		    }
		}
	    }
	    Bin {
		if { $len != 5 } {
		    error "ERROR: Bin requires 4 args: column lo hi list"
		}
		if { [catch {starbase_colnum T $arg1} col] == 0 } {
		    set value [expr int([starbase_get T $row $col])]
		} else {
		    error "ERROR: missing column: $arg1"
		}
		set tmin [lindex $method 2]
		set tmax [lindex $method 3]
		set tab  [lindex $method 4]
		set tsiz [llength $tab]
		if { $value < $tmin } {
		    set value $tmin
		}
		if { $value > $tmax } {
		    set value $tmax
		}
		set ind \
			[expr int((double($value-$tmin)/double($tmax-$tmin))*$tsiz)]
		if { $ind < 0 } {
		    set ind 0
		}
		if { $ind >= $tsiz } {
		    set ind [expr $tsiz - 1]
		}
		set value [lindex $tab $ind]
	    }
	    Lookup {
		if { $len < 3 } {
		    error "ERROR: Lookup requires 2 or more args: column {lval val} or {{lo hi} val}"
		}
		# read lookup list and initialize hash and/or range tables
		if { ![info exists lookup($token,n)] } {
		    set n 0
		    set lookup($token,type) HASH
		    foreach list [lrange $method 2 end] {
			switch [llength $list] {
			    2 {
				set a0 [lindex $list 0]
				set a1 [lindex $list 1]
				switch [llength $a0] {
				    1 {
					set lookup($token,$a0)      $a1
					set lookup($token,$n,lo)    $a0
					set lookup($token,$n,hi)    $a0
					set lookup($token,$n,value) $a1
				    }
				    2 {
					set r0 [lindex $a0 0]
					set r1 [lindex $a0 1]
					set lookup($token,type)     RANGE
					set lookup($token,$n,lo)    $r0
					set lookup($token,$n,hi)    $r1
					set lookup($token,$n,value) $a1
				    }
				    default {
					error "ERROR: Lookup entry '$a0' should be a hash value or 2 range values ($token)"
				    }
				}
			    }
			    default {
				error "ERROR: Lookup list '$list' should be {key value} ($token)"
			    }
			}
			incr n
		    }
		    set lookup($token,n) $n
		}
		if { [catch {starbase_colnum T $arg1} col] == 0 } {
		    set value [starbase_get T $row $col]
		} else {
		    error "ERROR: missing column: $arg1"
		}
		switch $lookup($token,type) {
		    HASH {
			if { [info exists lookup($token,$value)] } {
			    set value $lookup($token,$value)
			} else {
			    set catreg_err "missing hash entry for '$value' ($token)"
			    return $catreg_missing
			}
		    }
		    RANGE {
			set got 0
			for { set n 0 } { $n < $lookup($token,n) } { incr n } {
			    if { ($value >= $lookup($token,$n,lo)) &&
			         ($value <= $lookup($token,$n,hi)) } {
				set value $lookup($token,$n,value)
				set got 1;
				break;
			    }
			}
			if { $got == 0 } {
			    set catreg_err "'$value' out of range ($token)"
			    return $catreg_missing
			}
		    }
		    default {
			error "ERROR: unknown Lookup type: $lookup($token,type)"
		    }
		}
	    }
	    Eval {
		set value [eval [lrange $method 1 end]]
	    }
	    Uplevel {
		set value [uplevel [lrange $method 1 end]]
	    }
	    default {
		set value [lrange $method 0 end]
	    }
	}
	append values $value
    }
    return $values
}

#
# catreg -- convert catalog table into region string
#
proc catreg { t { m catreg_ds9 } } {
    global $t
    global catreg_tokens catreg_colors catreg_shapes
    global catreg_missing
    upvar $t T

    if { ![string compare $m catreg_ds9] } { upvar #0 $m M
    } else { 				     upvar    $m M }

    set result ""

    # try to determine how the RA and Dec are formatted
    if { [catch {starbase_hdrget T UFMT} oformat] != 0 } {
	set oformat "h d"
    }

    set raformat  [lindex $oformat 0]
    set decformat [lindex $oformat 1]

    # process prologue
    if [info exists M(BEGIN)] {
	append result [format "%s\n" [catreg_value $t 0 BEGIN $M(BEGIN)]]
    }

    # for each row in the catalog table ...
    for { set row 1 } { $row <= $T(Nrows) } { incr row } {
	set s $M(REGION)
	set skip 0
	# loop through possible replacement tokens ...
	foreach token $catreg_tokens {
	    if { $token == "REGION" } {
		continue
	    }
	    if { $token == "BEGIN" } {
		continue
	    }
	    if { $token == "END" } {
		continue
	    }
	    set templ [format "%%%s%%" $token]
	    # see if we have to process this token
	    if { [string first $templ $M(REGION)] == -1 } {
		continue
	    }
	    # better be a method for this token
	    if { ![info exists M($token)] } {
		error "ERROR: token '$token' not defined $M(REGION)"
	    }
	    # get value using the appropriate method
	    set value [catreg_value $t $row $token $M($token)]
	    if { $value == $catreg_missing } {
		set skip 1
		break
	    }
	    # token-specific processing
	    switch $token {
		SYSTEM {
		    # scat returns equinox as a decimal value
		    if { $value == "2000.0" } {
			set value fk5
		    }
		    if { $value == "1950.0" } {
			set value fk4
		    }
		    set system $value
		}
		SHAPE {
		    if { [string first $value $catreg_shapes] == -1 } {
			error "ERROR: unknown shape '$value' ($catreg_shapes)"
		    }
		    set shape $value
		}
		RA {
		    # convert to decimal degrees, if possible
		    if { $raformat != "" } {
			set value [uformat $raformat h: $value]
		    } else {
			set value [strtod $value]
		    }
		    set ra $value
		}
		DEC {
		    # convert to decimal degrees, if possible
		    if { $decformat != "" } {
			set value [uformat $decformat d: $value]
		    } else {
			set value [strtod $value]
		    }
		    set dec $value
		}
		SIZE {
		    # we have to ensure that we have the correct number of
		    # arguments for the specified shape. Sometimes we repeat
		    # args, sometimes we ignore them.
		    set arglist [split $value ", "]
		    set narg    [llength $arglist]
		    switch $shape {
			circle {
			    if { $narg > 1 } {
				set value [lindex $arglist 0]
			    }
			}
			ellipse {
			    if { ($narg < 2) || ($narg >3) } {
				set value [format "%s,%s" \
					  [lindex $arglist 0] \
					  [lindex $arglist 0] ]
			    }
			}
			box {
			    if { ($narg < 2) || ($narg >3) } {
				set value [format "%s,%s" \
					  [lindex $arglist 0] \
					  [lindex $arglist 0] ]
			    }
			}
		    }
		    set size $value
		}
		COLOR {
		    set color $value
		}
		TEXT {
		    if { $value != "{}" } {
			set value [format "{%s}" $value]
		    }
		    set text $value
		}
		TAG {
		    if { $value != "{}" } {
			set value [format "{%s}" $value]
		    }
		    set tag $value
		}
	    }
	    regsub -all -- $templ $s $value s
	}
	if { $skip == 0 } {
	    # tcl outputs the arc-seconds symbol with an unwanted back-quote
	    regsub -all -- {\\"} $s {"} s
	    append result [format "%s\n" $s]
	}
    }

    if [info exists M(END)] {
	append result [format "%s\n" [catreg_value $t 0 END $M(END)]]
    }
    return $result
}

# ####
#
# catget.tcl -- starbase catalog access routines
#
# ####

package require http

set catget_version 1.0b1

# load if we are not in the catget script
if { ![info exists catget_loaded] && ![info exists catreg_loaded] } {
    source "./w3browse.tcl"
    source "./nameserver.tcl"
    source "./table.tcl"
    source "./options.tcl"
    source "./convert.tcl"
    source "./catreg.tcl"
}

# default URLs containing the RDB catalog tables
set catalogsURL  http://cfa-www.harvard.edu/catalog/catalogs
set hcatalogsURL http://cfa-www.harvard.edu/catalog/heasarc

#
# starbase_http -- we rename the starbase_http routine in starbase.tcl
# to allow us to clean up catalog http input: mostly we remove the extra
# ESO fields.
#
rename starbase_http Starbase_http
proc starbase_http { D url w } {
    global $D
    global $w
    upvar #0 $D T
    upvar #0 $w wait

    set wait 0
    Starbase_http $D $url wait
    vwait wait

    # make sure we got something to work with
    if { ![info exists T(Ndshs)] || ($T(Ndshs) == 0)  } {
	return
    }

    # Set the number of columns to that indicated
    # by the dashline
    #
    set T(Ncols) $T(Ndshs)
    
    # If that last row is [EOD], wack it.
    #
    set Nrows $T(Nrows)

    while { ![string compare $T($Nrows,1) {[EOD]}]
	    || ![string compare $T($Nrows,1) {}]
	    || ![string compare $T($Nrows,1) {<pre>}] } {
	set Nrows [expr $Nrows-1]
	set T(Nrows) $Nrows
    }

    #starbase_writefp $D stderr
}

#
# catget -- return a catalog into a starbase table
#
proc catget { t orgcat ra dec rad args } {
    global $t
    global catalogsURL
    global hcatalogsURL
    global _strtod
    global H
    global I
    global wait
    global env
    upvar $t T

    # determine which organization/server and catalog is wanted
    set catlist [split $orgcat "@"]
    if { [llength $catlist] == 1 } {
      set want_cat [lindex $catlist 0]
      set want_org ""
    } else {
      set want_cat [lindex $catlist 0]
      set want_org [lindex $catlist 1]
    }
    set org "?"

    # look for user-specified URL for standard catalogs
    if { [info exists env(CAT_CATALOGS_URL)] } {
	starbase_read I $env(CAT_CATALOGS_URL)
    } else {
	starbase_http I $catalogsURL wait
    }

    # look for the specified catalog in the standard list
    set cat_col [starbase_colnum I cat]
    set org_col [starbase_colnum I org]
    for { set row 1 } { $row <= $I(Nrows) } { incr row } {
	set this_cat $I($row,$cat_col)
	set this_org $I($row,$org_col)
	if { ($want_cat == $this_cat) && \
	   ( ($want_org == "") || ($want_org == $this_org) ) } {
	    set org $this_org
	    set cat $this_cat
	    set desc    $I($row,[starbase_colnum I description])
	    set iformat $I($row,[starbase_colnum I iformat])
	    set oformat $I($row,[starbase_colnum I oformat])
	    set url     $I($row,[starbase_colnum I url])
	    set raformat  [lindex $iformat 0]
	    set decformat [lindex $iformat 1]
	    set radformat [lindex $iformat 2]
	    break;
	}
    }

    if { $org == "?" } {
	# look for user-specified URL for HEASARC catalogs
	if { [info exists env(CAT_HCATALOGS_URL)] } {
	    starbase_read H $env(CAT_HCATALOGS_URL)
	} else {
	    starbase_http H $hcatalogsURL wait
	}
	# look for the specified catalog in the HEASARC list
	set cat_col [starbase_colnum H cat]
	set org_col [starbase_colnum H org]
	for { set row 1 } { $row <= $H(Nrows) } { incr row } {
	    set this_cat $H($row,$cat_col)
	    set this_org $H($row,$org_col)
	    if { ($want_cat == $this_cat) && \
	       ( ($want_org == "") || ($want_org == $this_org) ) } {
		set org $this_org
		set cat $this_cat
		set desc    $H($row,[starbase_colnum H description])
		set iformat $H($row,[starbase_colnum H iformat])
	        set oformat $H($row,[starbase_colnum H oformat])
		set url     $H($row,[starbase_colnum H url])
		set raformat  [lindex $iformat 0]
		set decformat [lindex $iformat 1]
		set radformat [lindex $iformat 2]
		break;
	    }
	}
    }

    # better have something to work with
    if { $org == "?" } {
	error "ERROR: can't find catalog: $orgcat"
    }

    # convert ra,dec to decimal degree format
    set ra [strtod $ra]
    if { ($_strtod == 3) || ($_strtod == 4)  } {
      set ra [h2d $ra]
    }
    set dec [strtod $dec]
    set rad [strtod $rad]

    # convert ra,dec to required format for the query
    set ra  [uformat d $raformat  $ra]
    set dec [uformat d $decformat $dec]
    set rad [uformat d $radformat $rad]

    # process command line options
    set arglist [format "-cat %s -ra \"%s\" -dec \"%s\" -radius \"%s\" %s" $cat $ra $dec $rad $args]
    set url [catOptions $url $org $arglist]

    # make catalog query
    switch $org {
	heasarc {
	    w3browse_http $t $url
	}
	default {
	    starbase_http $t $url wait
	}
    }

    # add history information
    starbase_hdrset T  "ORG"    $org
    starbase_hdrset T  "CAT"    $cat
    starbase_hdrset T  "DESC"   $desc
    starbase_hdrset T  "UFMT"   $oformat
    starbase_hdrset T  "RA"     [uformat $raformat  dd $ra]
    starbase_hdrset T  "DEC"    [uformat $decformat dd $dec]
    starbase_hdrset T  "RADIUS" [uformat $radformat dd $rad]
    starbase_hdrset T  "PARAMS" [split $args]
    starbase_hdrset T  "URL"    $url
}

#
# catget_options -- display switches and options for catget
#
proc catget_options { fp args } {
    global catalogsURL
    global hcatalogsURL
    global optionsURL
    global wait
    global T
    global env

    set arg1 [lindex $args 0]
    set arg2 [lindex $args 1]

    if { ($arg1 != "-options") && ($arg1 != "-list") } {
	return 0
    }

    if { ($arg1 == "-options") } {
	if { [info exists env(CAT_OPTIONS_URL)] } {
	    starbase_read T $env(CAT_OPTIONS_URL)
	} else {
	    starbase_http T $optionsURL wait
	}
	set org_col     [starbase_colnum T org]
	set switch_col  [starbase_colnum T switch]
	set default_col [starbase_colnum T default]
	set desc_col    [starbase_colnum T description]
	puts $fp "COMMENT\tcat, ra, dec, radius are required positional args for all catalogs"
	puts $fp "org\tswitch\tdefault\tdescription"
	puts $fp "---\t------\t-------\t-----------"
	for { set row 1 } { $row <= $T(Nrows) } { incr row } {
	    puts $fp [format "%s\t%s\t%s\t%s"       \
		    $T($row,$org_col)     \
		    $T($row,$switch_col)  \
		    $T($row,$default_col) \
		    $T($row,$desc_col)]
	}
	return 1
    }

    if { ($arg2 != "heasarc") } {
	puts $fp "COMMENT\tCatalogs maintained at SAO are documented at:"
	puts $fp "SAODOC\thttp://tdc-www.harvard.edu/software/wcstools/wcstools.files.html"
	puts $fp "COMMENT\tCatalogs maintained at ESO/CADC are documented at:"
	puts $fp "ESODOC\thttp://cadcwww.dao.nrc.ca/skycat/skycat-server.html"
    }
    if { ($arg2 == "heasarc") || ($arg2 == "all") } {
	puts $fp "COMMENT\tCatalogs maintained at HEASARC are documented at:"
	puts $fp "HEADOC\thttp://heasarc.gsfc.nasa.gov/db-perl/W3Browse/w3catindex.pl"
    }

    puts $fp "catalog\torg\tdescription"
    puts $fp "-------\t-------\t-----------"

    if { ($arg2 != "heasarc") } {
	if { [info exists env(CAT_CATALOGS_URL)] } {
	    starbase_read T $env(CAT_CATALOGS_URL)
	} else {
	    starbase_http T $catalogsURL wait
	}
	for { set row 1 } { $row <= $T(Nrows) } { incr row } {
	    set cat     $T($row,[starbase_colnum T cat])
	    set org     $T($row,[starbase_colnum T org])
	    set desc    $T($row,[starbase_colnum T description])
	    puts $fp [format "%s\t%s\t%s" $cat $org $desc]
	}
    }

    if { ($arg2 == "heasarc") || ($arg2 == "all") } {
	if { [info exists env(CAT_HCATALOGS_URL)] } {
	    starbase_read T $env(CAT_HCATALOGS_URL)
	} else {
	    starbase_http T $hcatalogsURL wait
	}
	for { set row 1 } { $row <= $T(Nrows) } { incr row } {
	    set cat     $T($row,[starbase_colnum T cat])
	    set org     $T($row,[starbase_colnum T org])
	    set desc    $T($row,[starbase_colnum T description])
	    puts $fp [format "%s\t%s\t%s" $cat $org $desc]
	}
    }
    return 1
}
# ####
#
# catget.tcl -- Tcl main to execute catalog access routines
#
# ####

proc usage { argv0 } {
    global catget_version
    puts " "
    puts [format "Program: %s (version %s)" $argv0 $catget_version]
    puts " "
    puts "Purpose: catalog retrieval in a radius around a specified position,"
    puts "or object name resolution into a position (using SIMBAD or NED)"
    puts " "
    puts "Usage:"
    puts "------"
    puts [format "    %s \[-ds9\] cat\[@org\] ra dec radius \[options\]\t# catalog search" $argv0]
    puts [format "    %s ned|simbad object_name\t\t# name resolution" $argv0]
    puts " "
    puts "For a list of available catalogs, type:"
    puts "---------------------------------------"
    puts [format "    %s -list\t\t# Catalogs from SAO,ESO,CADC" $argv0]
    puts [format "    %s -list heasarc\t# More than 200 catalogs from HEASARC" $argv0]
    puts [format "    %s -list all\t\t# All catalogs" $argv0]
    puts " "
    puts "Optional global switches for catalog search:"
    puts "--------------------------------------------"
    puts "    -ds9\t\t# output ds9 regions (instead of starbase table)"
    puts " "
    puts "Required args for catalog search:"
    puts "---------------------------------"
    puts "    cat\t\t# Catalog to search (append '@org' if catalog is not unique)"
    puts "    ra\t\t# Right ascension of search position (h:m:s, deg, radr)"
    puts "    dec\t\t# Declination of search position (d:m:s, deg, radr)"
    puts "    radius\t# Search radius (d:m:s, deg, radr)"
    puts " "
    puts "Examples:"
    puts "---------"
    puts "    catget gsc@sao 12:0:0 14:0:0 .1"
    puts "    catget gsc@eso 180 14 0:6:0"
    puts " "
    puts "Required args for name resolution:"
    puts "----------------------------------"
    puts "    ned|simbad\t# Name resolution server to use"
    puts "    object_name\t# Object name to resolve into RA/Dec"
    puts " "
    puts "Examples:"
    puts "---------"
    puts "    catget ned coma"
    puts "    catget simbad m51"
    puts " "

    puts "For catalog searches, each organization supports different optional arguments."
    puts "These can be viewed by typing:"
    puts " "
    puts [format "    %s -options" $argv0]
    puts " "
    puts "Open catalog access is provided by:"
    puts " "
    puts "    Canadian Astronomy Data Centre (cadc)"
    puts "    European Southern Observatory (eso)"
    puts "    NASA High Energy Science Archive Research Center (heasarc)"
    puts "    Smithsonian Astrophysical Observatory (sao)"
    puts " "
    puts "Object name resolution is provided by:"
    puts " "
    puts "    NASA/IPAC (ned)"
    puts "    Centre de Donnees Astronomiques de Strasbourg (simbad)"
}

set a0 [lindex $argv 0]
set a1 [lindex $argv 1]
set doreg no

if { [file exists .catinit] } {
    source .catinit
} elseif { [file exists ~/.catinit] } {
    source ~/.catinit
}

# process catget command switches
if { $a0 == "-ds9" } {
    set doreg yes
    set argv [lreplace $argv 0 0]
    incr argc -1
    set a0 [lindex $argv 0]
    set a1 [lindex $argv 1]
}
if { $a0 == "-help" } {
    usage $argv0
    exit 0
}
if { $argc == 0 } { 
    usage $argv0
    exit 0
} elseif { $argc == 1 } {
    catget_options stdout $a0
    exit 0
} elseif { ($argc == 2) && ($a0 == "-list") } {
    catget_options stdout $a0 $a1
    exit 0
} elseif { ($argc == 2) && (($a0 == "ned") || ($a0 == "simbad")) } {
    name_server T $a0 $a1
    if { $doreg == "yes" } {
	puts [catget_regions T]
    } else {
	starbase_writefp T stdout
    }
    exit 0
} elseif { $argc >= 4 } {
    eval catget T $argv
    if { $doreg == "yes" } {
	puts [catreg T]
    } else {
	starbase_writefp T stdout
    }
    exit 0
} else {
    usage $argv0
    exit 1
}
